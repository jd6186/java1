package com.lec.java.review_oop;


public class Review_OOP {

	public static void main(String[] args) {
		
//		문제 1. 다형성이란 무엇인가??
//		TODO
		
		
		
		
		
		
//		문제 1. Vehicle, Car, HybridCar를 클래스로 정의하여라. 순서대로 오버라이딩 시켜(알지? displayInfo) > 근데 이 때 super로 하지말고 그냥 오버라이딩 시켜서 해봐 어떤식으로 작동하는지 눈으로봐 모르면 바로 01열어서 보고
//		TODO
		
		
		
		
		
		
		
		
//		문제 1. Vehicle v1 = new Vehicle();  여기서 v1타입은 무엇이며 어떤 타입을 받는가?
//		TODO
		
		
		
		
		
		
		
//		문제 1. 각 클래스들을 다 인스턴스 시키고 displayInfo()를 불러와라.
//		TODO
		
		
		
		
		
		
		
		
//		문제 1. 조상을 통해 새로운 Car와 Hybrid를 인스턴스 시켜봐라  가능한가?가능하다면 왜 가능한가?(객체 지향언어 시점에서 설명 ㄱ, 어떤 특성이 들어난 것인가? 모르면 바로 01번 봐라)
//		TODO
		
		
		
		
		
		
		
//		문제 1. 그럼 자손클래스도 부모클래스에 대입이 가능한가?
//		TODO
		
		
		
		
		
		
		
//		문제 1. 상속은 왜 사용하는 것인가?
//		TODO
		
		
		
		
		
		
		
//		문제 1. 상속관계로 정의할지 멤버관계로 정의할지 어떤 원리를 통해 판단할 수 있는가?
//		TODO
		
		
		
		
		
		
		
		
		
/////////////////////////////////////////////////////////////여기까지가 oop01////////////////////////////////////////////////////		
		
		
		
		
		
		
/////////////////////////////////////////////////////////////여기부터가 oop02////////////////////////////////////////////////////		
//		문제 1. 자 그럼 다형성을 활용해 Vehicle을 원소 3개를 가지는 배열로 바꾸고 각 클래스를 새로 인스턴스 시키는 배열을 만들어보라.
//		TODO
		
		
		
		
		
		System.out.println("여기서부터 배열로 출력하는 내용");
		System.out.println();
//		문제 1. 해당 클래스들을 한번에 인스턴스시키면서 displayInfo를 출력하는 구문을 만들어라. (기가 맥히지? 지렸지?)
//		TODO
		
		
		
		
		
		
//		문제 1. System.out.println(car[i]); 이런식으로 위에 클래스들이 속한 배열을 출력하면 뭐가 어떤식으로 출력되는가?
//		TODO
		
		
		
		
		
		
		
		
//		문제 1. 해당 메인 밑에 메소드를 하나 만들고(자동차 관련기능) 해당 메소드의 매개변수를 Vehicle로 설정하고 메인에서 각 차종별로 전부 이 메소드를 사용하게 해봐라
//		TODO
		
		
		
		
		
		
//		문제 1. 지렸지? 즉, 부모클래스를 잘 만들어두면 배열공유 메소드공유 등 다양한걸 그냥 부모클래스에 걸어서 다 쓸수 있어 개사기~
//		TODO
		
		
		
		
		
		
		
//		문제 1. 변수로 클래스를 받으면 뭘 할 수 있는가?
//		TODO
		
		
		
		
		
		
		
//		문제 1. 메소드의 리턴문으로 클래스를 받으면 뭘 할 수 있는가?
//		TODO
		
		
		
		
		
		
		
/////////////////////////////////////////////////////////////여기까지가 oop02////////////////////////////////////////////////////		
		
		
		
		
		
		
/////////////////////////////////////////////////////////////여기부터가 oop03////////////////////////////////////////////////////		
		
//		문제 1. 다형성의 가장 큰 단점은 무엇인가?
//		TODO
//		조상클래스 타입으로 자손클래스를 인스턴스 시켰을 때의 변수값을 가지고 자손클래스에만 존재하는 메소드를 불러오면 바로 에러뜬다.
//		이유는? 타입자체가 조상클래스인데 조상클래스에는 없는 내용을 불러왔기 때문에
				
				
//		문제 1. 단점을 해결하는 방법은 무엇인가?
//		TODO
//		명시적 형변환을 통해 해결할 수 있다.
		
		
//		문제 1. Hybrid의 인스턴스를 받은 변수를 활용해 명시적 형변환을 통해 setElectric 메소드를 사용해봐라.
//		TODO
		
		
//		문제 1. 그럼 Vehicle 인스턴스를 받은 변수가 Hybird로 명시적 형변환을 하면 문법적으로 문제가 되는가?
//		TODO
//		아니오
		
//		문제 1. 그럼 명시적 형변환을 하고 setElectric 메소드를 사용할 수 있는가?
//		TODO
//		아니오
		
		
//		문제 1. 사용할 수 없다면 왜 사용할 수 없는가?
//		TODO
//		ClassCastException에러 즉, 형변환 과정속에서 에러가 발생하기 때문이다.
//		왜냐면 이미 비히클의 자료밖에 없는 것이라 아무리 조상클래스 타입이라고 하더라도 받은게 Vehicle이니 Hybrid로 명시적 형변환 자체가 안되서 발생하는 문제인 것이다.(하지만 문법적으로는 문제가 없옹)
		
		
		
//		문제 1. 자 그럼 이런 캐스트에러와 컴파일에러의 차이점에 대해 설명하라.
//		TODO
//		컴파일 에러는 내가 지금 가져온 변수가 실행시키려는 메소드의 클래스로 인스턴스시킨 것이더라도 그 인스턴스를 받은 변수의 타입이 문제기 때문에 발생하는 에러다.
//		즉, 시작부터 문법적으로 타입 미스매치 때문에 생기는 문제다.
		
//		캐스트 에러는 문법적으로는 형변환을 통해 맞는 문법을 갖추었지만 사용하려는 메소드의 클래스로 도저히 변환자체가 불가능한 변수를 가져와 형변환을 시도했기 때문에 발생하는 에러다. 
		
		
		
		
/////////////////////////////////////////////////////////////여기까지가 oop03////////////////////////////////////////////////////		
		
		
		
		
		
/////////////////////////////////////////////////////////////여기부터가 oop04////////////////////////////////////////////////////		
		
//		문제 1. 추상클래스란 무엇이며 언제 사용되는가?(언제 호출가능하고 현실에선 어떤 곳에 사용되나?)
//		TODO
//		추상메소드를 가지고 있는 클래스
//		추상 클래스를 상속 받는 자손클래스에서 반드시 구현해내야될 메소드가 있을 경우 사용한다.
//		지금은 존재하지 않는 추상적 개념의 클래스지만 나중에 상속을 하고 자손클래스들을 통해 오버라이딩 되고 자손클래스는 해결할 문제를 해결한 뒤 그 값을 메인에 출력하는데 이 때 추상클래스가 같이 메인으로 가게된다.
//		이런 추상클래스가 있어서 프로그램 하청이 가능해진 것이다. 이 클래스를 만들고 자손클래스를 하청업체에 보내 자손클래스를 만들어 달라고 요구한 뒤 
//		자료를 보내주면 그 자료를 통해 이 해당 추상클래스를 메인으로 가지고 들어가게 된다.
		
		
		
//		문제 1. 추상클래스의 특징에 대해 설명하시오 (2가지)
//		TODO
//		추상클래스는 인스턴스를 할 수 없다. 왜? 추상적 개념만 존재할 뿐 실체가 없는 클래스니까
//		또한 단 하나의 추상메소드라도 해당 클래스에 있다면 반드시 추상클래스로 지정해줘야한다.

		
//		문제 1. 추상 메소드란 무엇인가? 언제 사용되는가?
//		TODO
//		추상적개념(= 원형(prototype))만 선언돼 있고 메소드의 본체가 없는 메소드
		
		
//		문제 1. 추상메소드의 특징에 대해 설명하시오(2가지)
//		TODO
//		메소드 본체가 없기 때문에 바디부분을 담당하는 {}가 없다.
//		메소드 원형 끝에 if가 {} 없을 때 처럼 세미콜론(;)으로 마무리된다.
		
		
		
//		문제 1. 지금 이 클래스 밑에 새로운 추상클래스를 만들고 해당 클래스를 상속받는 자손클래스를 만들어보라.
//		TODO
		
		
		
		
//		문제 1. 추상클래스를 만들 때 클래스는 어떻게 만들며 메소드는 어떻게 제작하는가?
//		TODO
//		abstract를 클래스 앞에 붙혀서 추상 클래스를 표현해주고 추상 메소드는 리턴타입 앞에 abstract를 붙혀 추상메소드를 나타낸다.

		
		
//		문제 1. 자손클래스에서는 반드시 무엇을 해야하는가?
//		TODO
//		반드시 작업해야하는 메소드를 오버라이딩 받아서 값을 부여해주게 된다.

		
		
//		문제 1. 만약 추상메소드를 오버라이딩하지 않으면 뭐라도 해야하는가? 이건 또 여기서 어떤 느낌이 들게 하는가?
//		TODO
//		자손클래스 또한 추상클래스로 남기라도 해야된다.
//		하청에 재하청 보내는 느낌?
		
		
		
		
		
/////////////////////////////////////////////////////////////여기까지가 oop04////////////////////////////////////////////////////	
		
		
		
		
		
		
/////////////////////////////////////////////////////////////여기부터가 oop05////////////////////////////////////////////////////		
		
		
/////////////////////////////////////////////////////////////여기까지가 oop05////////////////////////////////////////////////////		
		
//		문제 1. 스테틱은 무엇을 하지 않아도 사용가능한가? 또한 사용할 때 양식은 어떻게 되는가?
//		TODO
//		인스턴스를 하지 않아도 사용가능, 
//		클래스이름.스테틱이들어간 변수이름
		
		
		
		
//		문제 1. 인터페이스란 무엇인가?
//		TODO
//		모든 메소드가 public abstract로 선언되고
//		모든 멤버변수가 public static final로 선언된 클래스

		
		
		
		
//		문제 1. 그럼 사실 인터페이스 클래스는 무슨 클래스인가? 그리고 왜 인터페이스만 인터페이스라고 따로 부르는가?
//		TODO
//		abstract 클래스 즉, 추상클래슨데 특별한 기능이 있어서 다르게 부른다.
		
		
		
		
//		문제 1. 그럼 멤버변수에 초기화값을 바로 지정할 수 있는가 없는가?
//		TODO
//		당연히 있다. 그건 문제가 안됌
		
		
		
		
//		문제 1. 인터페이스만이 가지는 장점이 무엇인가? 그리고 이 장점은 왜 인터페이스만이 가지고 있는가?
//		TODO
//		다중상속이 가능하다.
//		그러게 왜 인터페이스만 다중상속이 허락되었나? 
		
		
		
		
//		문제 1. 인터페이스를 선언하는 방법은 무엇인가?
//		TODO
//		interface + 클래스이름 {
//		}
		
		
		
		
//		문제 1. 인터페이스 내부의 멤버면수는 어떤 형태인가? 그리고 그렇게 작성하지 않았을 시 발생하는 일을 쓰시오(아예 안썻을 때 이상한걸 썻을 때 2가지 상황으로 나누어 설명)
//		TODO
//		public static final 변수이름
//		멤버 변수 쓸 때 수식어 아예 안쓰고 타입과 이름만 쓰면 디폴트 수식어를 가지잖아 원래? 근데 디폴트는 public static final로 자동 형변환이 되
//		근데 바보같이 직접적으로 private같은 수식어를 멤버변수 앞에 써버리면 바로 에러!
		
		
		
		
//		문제 1. 메소드는 어떤 형태로 작성되는가?  만약 그렇게 작성하지 않으면 어떻게 되는가?(아예 안썻을 때 이상한걸 썻을 때 2가지 상황으로 나누어 설명)
//		TODO
//		public static void 변수이름(); 형태가 기본이고
//		만약 리턴타입 + 변수이름만 쓰면 알아서저렇게 형변환을 시켜준다.
//		근데 만약 다른 private나 int나 이런거 쓰면 바로 에러
		
		
		
		
//		문제 1. 이런 인터페이스를 사용하기 위해서 사용하는 자손클래스의 이름은 무엇인가?
//		TODO
//		특이하게도 implements라는 이름으로 자손이 정해져있다.
		
		
		
		
//		문제 1. 이 클래스는 어떻게 클래스 구문을 작성하는가?
//		TODO
//		class + 클래스이름 + implements + 부모클래스이름{
//			} 형태로 작성된다.
		
		
		
		
//		문제 1. implements 클래스는 반드시 무엇을 해야하는가?(해야할 것 = 2가지) 그리고 왜 해야하는가?(각각 설명 ㄱㄱ)
//		TODO
//		상속과 오버라이딩 왜? 자손클래스로 살아갈 운명이고 이것도 결국 엡스트릭트 클래스니까.
		
		
		
		
//		문제 1. 인터페이스의 최고의 장점에 대해 쓰고 
//		상속을 받을 시 같은 시그니처를 가진 메소드를 양쪽에서 동시에 받을 경우 어떻게 오버라이딩되는지 설명하시오?
//		TODO
//		다중상속이 가능하다.
//		시그니처가 완전히 동일하다면 각각 출력되는 것이 아니라 1개만 출력된다.

		
		
		
		
//		문제 1. 다중 상속은 어떤식으로 할 수 있는가?
//		TODO
//		class classImpl implements 조상클래스이름1, 조상클래스이름2 {	
//		}
//		이런 형태로 출력가능하며 ,를 통해 각 클래스들을 다중 상속 시켜준다.
		
		
		
		
//		문제 1. implements 클래스는 그럼 무엇을 하는 클래스인가?
//		TODO
//		부모클래스에 있는 메소드는 바디가 정해져 있지않은데 그 메소드의 바디를 만들어 내용을 입력해주는 역할을 하는 클래스다.
		
		
		
		
		
//		문제 1. 위와 같은 과정을 무엇이라 부르는가? 
//		TODO
//		구현

		
		
		
		
//		문제 1. 그럼 그 implements클래스를 메인으로 불러와 메소드를 출력해보라.
//		TODO

		
		
		
		
//		문제 1. 다중 상속을 받은 implements클래스를 가져왔다면 부모클래스 두개가 이름은 같은데 값이 다른 멤버변수를 가지고 있을 때 
//		그 값을 메인에서 출력하력하면 어떻게 되는가? 
//		TODO
//		The field 변수 is ambiguous
//		즉, 그 변수는 너무 추상적이어서 출력할 수 없다는 애러가 뜬다.
		
		
		
		
		
//		문제 1. 에러가 뜬다면 해결 방법은 무엇인가? 그리고 그 방법이 어떻게 가능한가?(abstract클래스가 가지는 한계와 연관지어 설명 ㄱㄱ)
//		TODO
//		에러발생시 해결법은 해당인터페이스를 직접지목해 값을 알려달라고 하는 것이다.
//		인터페이스라 원래는 직접출력이 불가능하지만 이미 자손클래스가 메인에 입력되었기 때문에 그 타이밍에 꼽사리 껴서 들어와있는 상태다 
//		따라서 System.out.println(Interface클래스이름.멤버변수이름);를 해주면 출력가능하다. 
//		왜? 이건 다중상속된 클래스에서 가져오는게 아니라 해당 클래스에 직접 그 값을 가져다 달라고 요청하는 것이기 때문에 가능
		
		
		
		
//		문제 1. 밑에 같은 상속구조를 가지게 되면 어떤 문제가 발생하는가?
/*
		A
		
	▼		▼
	
	B		B1
	
	 →     ←
	
		▼
		
		C
		

*/
//		TODO
		
		
		
		
		
		
		
/////////////////////////////////////////////////////////////여기부터가 oop06////////////////////////////////////////////////////		
		
		
/////////////////////////////////////////////////////////////여기까지가 oop06////////////////////////////////////////////////////		
		
		
		
		
		
		
		
		
/////////////////////////////////////////////////////////////여기부터가 oop07////////////////////////////////////////////////////		
		
		
/////////////////////////////////////////////////////////////여기까지가 oop07////////////////////////////////////////////////////		

		
		
		
		
		
		
		
	} // end main
	
	public static void driving(Vehicle v) { // 이렇게 변수로 클래스를 받을 때는 스테틱으로 받아줘라.
		System.out.println(v.getSpeed());
	}
	
	
	
} // end class
